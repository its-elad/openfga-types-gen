import { AuthorizationModel, TypeDefinition, Userset } from "@openfga/sdk";

export interface TypeGeneratorOptions {
  includeComments?: boolean;
  includeSDKCompatibility?: boolean;
  namespacePrefix?: string;
  includeUtilityTypes?: boolean;
}

export class TypeGenerator {
  private options: Required<TypeGeneratorOptions>;

  constructor(options: TypeGeneratorOptions = {}) {
    this.options = {
      includeComments: true,
      includeSDKCompatibility: true,
      namespacePrefix: "FGA",
      includeUtilityTypes: true,
      ...options,
    };
  }

  public generateTypes(model: AuthorizationModel): string {
    const lines: string[] = [];

    // Add header comment
    lines.push("/**");
    lines.push(" * Generated OpenFGA TypeScript Types");
    lines.push(" * ");
    lines.push(" * This file was automatically generated from an OpenFGA authorization model.");
    lines.push(" * Do not edit this file directly. Regenerate it using the openfga-types-generator.");
    lines.push(" * ");
    lines.push(` * Model ID: ${model.id}`);
    lines.push(` * Schema Version: ${model.schema_version}`);
    lines.push(` * Generated: ${new Date().toISOString()}`);
    lines.push(" */");
    lines.push("");

    // Import OpenFGA SDK types if compatibility is enabled
    if (this.options.includeSDKCompatibility) {
      lines.push(
        "import type { TupleKey as SDKTupleKey, RelationshipCondition } from '@openfga/sdk';",
      );
      lines.push("");
    }

    // Extract all object types
    const objectTypes = model.type_definitions?.map((td) => td.type) || [];

    // Generate individual object type constants
    const objectTypeConstants: string[] = [];

    lines.push("// Individual Object Type Constants");
    objectTypes.forEach((objectType) => {
      const objectTypeConstant = `${this.options.namespacePrefix}Object${this.capitalize(objectType)}`;
      objectTypeConstants.push(objectTypeConstant);
      lines.push(`export const ${objectTypeConstant} = '${objectType}' as const;`);
    });
    lines.push("");

    // Generate object type union
    lines.push("// Object Types");
    lines.push(`export type ${this.options.namespacePrefix}ObjectType = ${objectTypeConstants.map((c) => `typeof ${c}`).join(" | ")};`);
    lines.push("");

    // Generate relations for each object type
    const relationsByObject = this.extractRelationsByObject(model.type_definitions || []);

    lines.push("// Relations by Object Type");
    const relationsTypeByObjectTypeName: Record<string, string> = {};
    const relationsConstantByObjectTypeName: Record<string, string> = {};
    Object.entries(relationsByObject).forEach(([objectType, relations]) => {
      if (relations.length > 0) {
        // Generate relation constants
        const constantName = `${this.options.namespacePrefix}${this.capitalize(objectType)}RelationConstants`;
        relationsConstantByObjectTypeName[objectType] = constantName;
        lines.push(`export const ${constantName} = {`);
        relations.forEach((relation) => {
          lines.push(`  ${relation}: '${relation}' as const,`);
        });
        lines.push("} as const;");

        const typeName = `${this.options.namespacePrefix}${this.capitalize(objectType)}Relations`;
        relationsTypeByObjectTypeName[objectType] = typeName;
        lines.push(`export type ${typeName} = typeof ${constantName}[keyof typeof ${constantName}];`);
        lines.push("");
      }
    });

    // Generate all relations union
    const allRelations = [...new Set(Object.values(relationsByObject).flat())];
    lines.push("// All Relations");
    lines.push(
      `export type ${this.options.namespacePrefix}Relation = ${Object.values(relationsTypeByObjectTypeName)
        .map((t) => `${t}`)
        .join(" | ")};`,
    );
    lines.push("");

    // Generate relation categorization based on userset analysis
    const relationCategories = this.categorizeRelations(model.type_definitions || []);

    // Generate discriminated union types for TupleKey
    lines.push("// Discriminated Union Types for TupleKey");
    lines.push("// These types ensure type safety by constraining relations based on object type");
    lines.push("");

    const tupleKeyTypes: string[] = Object.entries(relationsTypeByObjectTypeName).map(([objectType, typeName]) => {
      return `  | { object: \`${objectType}:\${string}\`; relation: ${typeName}; user: string; condition?: RelationshipCondition }`;
    });

    if (this.options.includeSDKCompatibility) {
      lines.push("// Type-safe TupleKey that constrains relations based on object type");
      lines.push(`export type ${this.options.namespacePrefix}TupleKey =`);
      lines.push(tupleKeyTypes.join("\n"));
      lines.push(";");
      lines.push("");

      lines.push("// Type guard to check if a TupleKey is type-safe");
      lines.push(`export function isFGATupleKey(tupleKey: SDKTupleKey): tupleKey is ${this.options.namespacePrefix}TupleKey {`);
      lines.push("  const [objectType] = tupleKey.object.split(':');");
      lines.push("  switch (objectType) {");

      objectTypes.forEach((objectType) => {
        lines.push(`    case '${objectType}':`);
        lines.push(
          `      return Object.values(${relationsConstantByObjectTypeName[objectType] || "{}"}).includes(tupleKey.relation as any);`,
        );
      });

      lines.push("    default:");
      lines.push("      return false;");
      lines.push("  }");
      lines.push("}");
      lines.push("");
    }

    // Generate utility types if requested
    if (this.options.includeUtilityTypes) {
      lines.push("// Utility Types");

      // Type for extracting object type from object string
      lines.push("export type ExtractObjectType<T extends string> = T extends `${infer U}:${string}` ? U : never;");
      lines.push("");

      // Type for checking if relation is valid for object type
      lines.push("export type IsValidRelation<");
      lines.push("  TObjectType extends string,");
      lines.push("  TRelation extends string");
      lines.push("> = TObjectType extends keyof typeof relationsByObjectType");
      lines.push("  ? TRelation extends (typeof relationsByObjectType)[TObjectType][number]");
      lines.push("    ? true");
      lines.push("    : false");
      lines.push("  : false;");
      lines.push("");

      // Runtime mapping object for utility types
      lines.push("const relationsByObjectType = {");
      objectTypes.forEach((objectType) => {
        lines.push(
          `  '${objectType}': ${
            relationsConstantByObjectTypeName[objectType] ? `Object.values(${relationsConstantByObjectTypeName[objectType]})` : "[]"
          },`,
        );
      });
      lines.push("} as const;");
      lines.push("");
    }

    // Generate model metadata
    lines.push("// Model Metadata");
    lines.push(`export const ${this.options.namespacePrefix}ModelMetadata = {`);
    lines.push(`  modelId: '${model.id}',`);
    lines.push(`  schemaVersion: '${model.schema_version}',`);
    lines.push(`  objectTypes: [${objectTypes.map((t) => `'${t}'`).join(", ")}] as const,`);
    lines.push(`  relations: [${allRelations.map((r) => `'${r}'`).join(", ")}] as const,`);
    lines.push("  relationsByObject: relationsByObjectType,");
    lines.push("  relationCategories: {");
    Object.entries(relationCategories).forEach(([category, relations]) => {
      lines.push(`    ${category}: [${relations.map((r) => `'${r}'`).join(", ")}] as const,`);
    });
    lines.push("  } as const,");
    lines.push(`  generatedAt: '${new Date().toISOString()}' as const,`);
    lines.push("} as const;");
    lines.push("");

    // Generate type-safe helper functions
    if (this.options.includeSDKCompatibility) {
      lines.push("// Type-safe Helper Functions");

      lines.push("/**");
      lines.push(" * Creates a type-safe tuple key builder for a specific object type");
      lines.push(" */");
      lines.push("export function createTupleKeyBuilder<T extends string>(objectType: T) {");
      lines.push("  return function<R extends string>(objectId: string, relation: R, user: string, condition?: RelationshipCondition) {");
      lines.push("    return {");
      lines.push("      object: `${objectType}:${objectId}` as const,");
      lines.push("      relation,");
      lines.push("      user,");
      lines.push("      condition");
      lines.push("    };");
      lines.push("  };");
      lines.push("}");
      lines.push("");

      lines.push("/**");
      lines.push(" * Validates if a relation is valid for a given object type");
      lines.push(" */");
      lines.push("export function isValidRelationForObjectType(objectType: string, relation: string): boolean {");
      lines.push(
        `  const objectRelations = ${this.options.namespacePrefix}ModelMetadata.relationsByObject[objectType as keyof typeof ${this.options.namespacePrefix}ModelMetadata.relationsByObject];`,
      );
      lines.push("  return objectRelations ? ((objectRelations || []) as readonly string[]).includes(relation) : false;");
      lines.push("}");
      lines.push("");

      lines.push("/**");
      lines.push(" * Gets all valid relations for a given object type");
      lines.push(" */");
      lines.push("export function getRelationsForObjectType(objectType: string): readonly string[] {");
      lines.push(
        `  return ${this.options.namespacePrefix}ModelMetadata.relationsByObject[objectType as keyof typeof ${this.options.namespacePrefix}ModelMetadata.relationsByObject] ?? [];`,
      );
      lines.push("}");
      lines.push("");
    }

    return lines.join("\n");
  }

  private generateRelationInfos(typeDefinitions: TypeDefinition[]): Array<{
    objectType: string;
    relation: string;
    category: "direct" | "computed" | "inherited" | "indirect";
    description?: string;
  }> {
    const infos: Array<{
      objectType: string;
      relation: string;
      category: "direct" | "computed" | "inherited" | "indirect";
      description?: string;
    }> = [];

    typeDefinitions.forEach((typeDef) => {
      Object.entries(typeDef.relations || {}).forEach(([relationName, userset]) => {
        const category = this.categorizeUserset(userset);
        const description = this.generateUsersetDescription(userset);

        infos.push({
          objectType: typeDef.type,
          relation: relationName,
          category,
          description,
        });
      });
    });

    return infos;
  }

  private generateUsersetDescription(userset: Userset): string {
    if (userset.this) {
      return "Direct assignment - users can be directly assigned this relation";
    }
    if (userset.computedUserset) {
      return `Computed from relation: ${userset.computedUserset.relation}`;
    }
    if (userset.tupleToUserset) {
      return `Inherited from ${userset.tupleToUserset.tupleset.relation} via ${userset.tupleToUserset.computedUserset.relation}`;
    }
    if (userset.union) {
      return "Union of multiple relations";
    }
    if (userset.intersection) {
      return "Intersection of multiple relations";
    }
    if (userset.difference) {
      return "Difference between relations";
    }
    return "Complex relation definition";
  }

  private extractRelationsByObject(typeDefinitions: TypeDefinition[]): Record<string, string[]> {
    const result: Record<string, string[]> = {};

    typeDefinitions.forEach((typeDef) => {
      const relations = Object.keys(typeDef.relations || {});
      result[typeDef.type] = relations;
    });

    return result;
  }

  private categorizeRelations(typeDefinitions: TypeDefinition[]): Record<string, string[]> {
    const categories: Record<string, string[]> = {
      direct: [],
      computed: [],
      inherited: [],
      indirect: [],
    };

    typeDefinitions.forEach((typeDef) => {
      Object.entries(typeDef.relations || {}).forEach(([relationName, userset]) => {
        const category = this.categorizeUserset(userset);
        const relationKey = `${typeDef.type}#${relationName}`;
        categories[category].push(relationKey);
      });
    });

    return categories;
  }

  private categorizeUserset(userset: Userset): "direct" | "computed" | "inherited" | "indirect" {
    if (userset.this) {
      return "direct";
    }
    if (userset.computedUserset) {
      return "computed";
    }
    if (userset.tupleToUserset) {
      return "inherited";
    }
    if (userset.union || userset.intersection || userset.difference) {
      return "indirect";
    }
    return "direct"; // fallback
  }

  private capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
}
