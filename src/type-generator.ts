import { AuthorizationModel, TypeDefinition, Userset } from "@openfga/sdk";
import ts from "typescript";

const factory = ts.factory;


export interface TypeGeneratorOptions {
  namespacePrefix?: string;
  includeUtilityTypes?: boolean;
}

export class TypeGenerator {
  private options: Required<TypeGeneratorOptions>;
  private readonly RELATIONS_BY_OBJECT_TYPE_NAME = "relationsByObjectType";
  private readonly TUPLE_KEY_TYPE_NAME: string;
  private readonly ALL_RELATIONS_TYPE_NAME: string;
  private readonly OBJECT_TYPE_NAME: string;
  private readonly MODEL_METADATA_NAME: string;

  constructor(options: TypeGeneratorOptions = {}) {
    this.options = {
      namespacePrefix: "FGA",
      includeUtilityTypes: true,
      ...options,
    };

    this.TUPLE_KEY_TYPE_NAME = `${this.options.namespacePrefix}TupleKey`;
    this.ALL_RELATIONS_TYPE_NAME = `${this.options.namespacePrefix}Relation`;
    this.OBJECT_TYPE_NAME = `${this.options.namespacePrefix}ObjectType`;
    this.MODEL_METADATA_NAME = `${this.options.namespacePrefix}ModelMetadata`
  }

  public generateTypes(model: AuthorizationModel): string {
    const toPrint: (string | ts.Node)[] = [];

    // Add header comment
    toPrint.push("/**");
    toPrint.push(" * Generated OpenFGA TypeScript Types");
    toPrint.push(" * ");
    toPrint.push(" * This file was automatically generated from an OpenFGA authorization model.");
    toPrint.push(" * Do not edit this file directly. Regenerate it using the openfga-types-generator.");
    toPrint.push(" * ");
    toPrint.push(` * Model ID: ${model.id}`);
    toPrint.push(` * Schema Version: ${model.schema_version}`);
    toPrint.push(` * Generated: ${new Date().toISOString()}`);
    toPrint.push(" */");
    toPrint.push("");

    // Add imports if SDK compatibility is enabled
    const importDecl = this.createImportDeclaration(["RelationshipCondition"], "@openfga/sdk");
    toPrint.push(importDecl);
    toPrint.push("");

    // Extract all object types
    const objectTypes = model.type_definitions?.map((td) => td.type) || [];
    const relationsByObject = this.extractRelationsByObject(model.type_definitions || []);
    const relationCategories = this.categorizeRelations(model.type_definitions || []);
    const allRelations = [...new Set(Object.values(relationsByObject).flat())];

    // Generate individual object type constants using AST factory
    toPrint.push("// Individual Object Type Constants");
    const objectTypeConstantsDec = this.createConstAssertionDeclarations(
      objectTypes.map((objectType) => ({ name: `${this.options.namespacePrefix}Object${this.capitalize(objectType)}`, value: objectType })),
      true
    );
    toPrint.push(objectTypeConstantsDec);
    toPrint.push("");

    // Generate object type union
    toPrint.push("// Object Types");
    const objectTypeUnion = this.createTypeAliasDeclaration(
      `${this.OBJECT_TYPE_NAME}`,
      factory.createUnionTypeNode(
        objectTypeConstantsDec.declarationList.declarations.map((dec) =>
          factory.createTypeQueryNode(factory.createIdentifier(ts.isIdentifier(dec.name) ? dec.name.text : dec.name.getText()))
        )
      )
    );
    toPrint.push(objectTypeUnion);
    toPrint.push("");

    // Generate relations for each object type
    const relationsTypeNameByObjectType: Record<string, string> = {};
    const relationsConstantNameByObjectType: Record<string, string> = {};

    toPrint.push("// Relations by Object Type");
    Object.entries(relationsByObject).forEach(([objectType, relations]) => {
      if (relations.length > 0) {
        // Generate relation constants object
        const constantName = `${this.options.namespacePrefix}${this.capitalize(objectType)}RelationConstants`;
        const typeName = `${this.options.namespacePrefix}${this.capitalize(objectType)}Relations`;
        relationsConstantNameByObjectType[objectType] = constantName;
        relationsTypeNameByObjectType[objectType] = typeName;

        const { constStatement, typeAlias } = this.createRelationConstantAndTypeAlias(constantName, typeName, relations);
        toPrint.push(constStatement);
        toPrint.push(typeAlias);
        toPrint.push("");
      }
    });

    // Generate all relations union type
    toPrint.push("// All Relations");
    if (Object.values(relationsTypeNameByObjectType).length > 0) {
      const relationUnionType = this.createTypeAliasDeclaration(
        `${this.ALL_RELATIONS_TYPE_NAME}`,
        factory.createUnionTypeNode(
          Object.values(relationsTypeNameByObjectType).map((typeName) =>
            factory.createTypeReferenceNode(factory.createIdentifier(typeName))
          )
        )
      );
      toPrint.push(relationUnionType);
    }
    toPrint.push("");

    // Generate discriminated union types for TupleKey using string fallback
    toPrint.push("// Discriminated Union Types for TupleKey");
    toPrint.push("// These types ensure type safety by constraining relations based on object type");
    toPrint.push("");

    // Generate TupleKey types using TypeScript factory
    const tupleKeyTypeMembers = Object.entries(relationsTypeNameByObjectType).map(([objectType, typeName]) => {
      return factory.createTypeLiteralNode([
        factory.createPropertySignature(
          undefined,
          "object",
          undefined,
          factory.createTemplateLiteralType(factory.createTemplateHead(`${objectType}:`), [
            factory.createTemplateLiteralTypeSpan(
              factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),
              factory.createTemplateTail("")
            ),
          ])
        ),
        factory.createPropertySignature(
          undefined,
          "relation",
          undefined,
          factory.createTypeReferenceNode(factory.createIdentifier(typeName))
        ),
        factory.createPropertySignature(undefined, "user", undefined, factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword)),
        factory.createPropertySignature(
          undefined,
          "condition",
          factory.createToken(ts.SyntaxKind.QuestionToken),
          factory.createTypeReferenceNode("RelationshipCondition")
        ),
      ]);
    });

    toPrint.push("// Type-safe TupleKey that constrains relations based on object type");
    const tupleKeyTypeAlias = this.createTypeAliasDeclaration(
      this.TUPLE_KEY_TYPE_NAME,
      tupleKeyTypeMembers.length > 0
        ? factory.createUnionTypeNode(tupleKeyTypeMembers)
        : factory.createKeywordTypeNode(ts.SyntaxKind.NeverKeyword)
    );
    toPrint.push(tupleKeyTypeAlias);
    toPrint.push("");

    // Generate utility types if requested using string fallback
    if (this.options.includeUtilityTypes) {
      toPrint.push("// Utility Types");
      toPrint.push("");

      // Type for extracting object type from object string
      toPrint.push("export type ExtractObjectType<T extends string> = T extends `${infer U}:${string}` ? U : never;");
      toPrint.push("");

      // Type for checking if relation is valid for object type
      toPrint.push("export type IsValidRelation<");
      toPrint.push("  TObjectType extends string,");
      toPrint.push("  TRelation extends string");
      toPrint.push(`> = TObjectType extends keyof typeof ${this.RELATIONS_BY_OBJECT_TYPE_NAME}`);
      toPrint.push(`  ? TRelation extends (typeof ${this.RELATIONS_BY_OBJECT_TYPE_NAME})[TObjectType][number]`);
      toPrint.push("    ? true");
      toPrint.push("    : false");
      toPrint.push("  : false;");
      toPrint.push("");

      const relationsByObjectTypeProperties = objectTypes.map((objectType) => {
        return factory.createPropertyAssignment(
          factory.createStringLiteral(objectType),
          relationsConstantNameByObjectType[objectType]
            ? factory.createCallExpression(
                factory.createPropertyAccessExpression(factory.createIdentifier("Object"), "values"),
                undefined,
                [factory.createIdentifier(relationsConstantNameByObjectType[objectType])]
              )
            : factory.createArrayLiteralExpression([], false)
        );
      });

      const relationsByObjectTypeDecl = factory.createVariableStatement(
        [factory.createModifier(ts.SyntaxKind.ExportKeyword)],
        factory.createVariableDeclarationList(
          [
            factory.createVariableDeclaration(
              this.RELATIONS_BY_OBJECT_TYPE_NAME,
              undefined,
              undefined,
              factory.createAsExpression(
                factory.createObjectLiteralExpression(relationsByObjectTypeProperties, true),
                factory.createTypeReferenceNode("const")
              )
            ),
          ],
          ts.NodeFlags.Const
        )
      );

      toPrint.push(relationsByObjectTypeDecl);
      toPrint.push("");
    }

    // Generate model metadata using string fallback
    toPrint.push("// Model Metadata");
    toPrint.push(`export const ${this.MODEL_METADATA_NAME} = {`);
    toPrint.push(`  modelId: '${model.id}',`);
    toPrint.push(`  schemaVersion: '${model.schema_version}',`);
    toPrint.push(`  objectTypes: [${objectTypes.map((t) => `'${t}'`).join(", ")}] as const,`);
    toPrint.push(`  relations: [${allRelations.map((r) => `'${r}'`).join(", ")}] as const,`);
    toPrint.push(`  relationsByObject: ${this.RELATIONS_BY_OBJECT_TYPE_NAME},`);
    toPrint.push("  relationCategories: {");
    Object.entries(relationCategories).forEach(([category, relations]) => {
      toPrint.push(`    ${category}: [${relations.map((r) => `'${r}'`).join(", ")}] as const,`);
    });
    toPrint.push("  } as const,");
    toPrint.push(`  generatedAt: '${new Date().toISOString()}' as const,`);
    toPrint.push("} as const;");
    toPrint.push("");

    // Generate helper functions using string fallback
    toPrint.push("// Type-safe Helper Functions");
    toPrint.push("");

    // Function to format object ID
    toPrint.push("/**");
    toPrint.push(" * Formats a tuple key object into a string representation");
    toPrint.push(" */");
    toPrint.push(
      `export function formatFGAObjectId<T extends ${this.OBJECT_TYPE_NAME}>(object: { type: T, id: string }): \`\${T}:\${string}\` {`
    );
    toPrint.push("  return `${object.type}:${object.id}`;");
    toPrint.push("}");
    toPrint.push("");

    // Function to parse object ID
    toPrint.push("/**");
    toPrint.push(" * Parses a formatted object ID string into an object type and ID");
    toPrint.push(" */");
    toPrint.push(`export function parseFGAObjectId(objectId: string): { type: ${this.OBJECT_TYPE_NAME}, id: string } | null {`);
    toPrint.push("  const [objectType, id] = objectId.split(':', 2);");
    toPrint.push(`  if (objectType && id) return { type: objectType as ${this.OBJECT_TYPE_NAME}, id };`);
    toPrint.push("  return null;");
    toPrint.push("}");
    toPrint.push("");

    toPrint.push("/**");
    toPrint.push(" * Creates a type-safe tuple key for a specific object type");
    toPrint.push(" */");
    toPrint.push(`export function createTupleKey<T extends ${this.OBJECT_TYPE_NAME}>(`);
    toPrint.push("  objectType: T,");
    toPrint.push("  objectId: string,");
    toPrint.push(`  relation: (typeof ${this.RELATIONS_BY_OBJECT_TYPE_NAME})[T][number],`);
    toPrint.push("  user: string,");
    toPrint.push("  condition?: RelationshipCondition,");
    toPrint.push(") {");
    toPrint.push("  return {");
    toPrint.push("    object: formatFGAObjectId({ type: objectType, id: objectId }),");
    toPrint.push("    relation,");
    toPrint.push("    user,");
    toPrint.push("    condition");
    toPrint.push("  };");
    toPrint.push("};");
    toPrint.push("");

    toPrint.push("/**");
    toPrint.push(" * Validates if a relation is valid for a given object type");
    toPrint.push(" */");
    toPrint.push(`export function isValidRelationForObjectType(objectType: ${this.OBJECT_TYPE_NAME}, relation: string): boolean {`);
    toPrint.push(
      `  const objectRelations = ${this.RELATIONS_BY_OBJECT_TYPE_NAME}[objectType as keyof typeof ${this.RELATIONS_BY_OBJECT_TYPE_NAME}];`
    );
    toPrint.push("  return objectRelations ? ((objectRelations || []) as readonly string[]).includes(relation) : false;");
    toPrint.push("}");
    toPrint.push("");

    const printer = ts.createPrinter();
    const sourceFile = ts.createSourceFile("temp.ts", "", ts.ScriptTarget.Latest);
    return toPrint
      .map((data) => (typeof data === "string" ? data : printer.printNode(ts.EmitHint.Unspecified, data, sourceFile)))
      .join("\n");
  }

  private extractRelationsByObject(typeDefinitions: TypeDefinition[]): Record<string, string[]> {
    const result: Record<string, string[]> = {};

    typeDefinitions.forEach((typeDef) => {
      const relations = Object.keys(typeDef.relations || {});
      result[typeDef.type] = relations;
    });

    return result;
  }

  private categorizeRelations(typeDefinitions: TypeDefinition[]): Record<string, string[]> {
    const categories: Record<string, string[]> = {
      direct: [],
      computed: [],
      inherited: [],
      indirect: [],
    };

    typeDefinitions.forEach((typeDef) => {
      Object.entries(typeDef.relations || {}).forEach(([relationName, userset]) => {
        const category = this.categorizeUserset(userset);
        const relationKey = `${typeDef.type}#${relationName}`;
        categories[category].push(relationKey);
      });
    });

    return categories;
  }

  private categorizeUserset(userset: Userset): "direct" | "computed" | "inherited" | "indirect" {
    if (userset.this) {
      return "direct";
    }
    if (userset.computedUserset) {
      return "computed";
    }
    if (userset.tupleToUserset) {
      return "inherited";
    }
    if (userset.union || userset.intersection || userset.difference) {
      return "indirect";
    }
    return "direct"; // fallback
  }

  private capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  private createImportDeclaration(namedImports: string[], moduleSpecifier: string): ts.ImportDeclaration {
    return factory.createImportDeclaration(
      undefined,
      factory.createImportClause(
        true,
        undefined,
        factory.createNamedImports(
          namedImports.map((importName) => {
            const parts = importName.split(" as ");
            return factory.createImportSpecifier(
              false,
              parts.length > 1 ? factory.createIdentifier(parts[0]) : undefined,
              factory.createIdentifier(parts.length > 1 ? parts[1] : parts[0])
            );
          })
        )
      ),
      factory.createStringLiteral(moduleSpecifier),
      undefined
    );
  }

  private createConstAssertionDeclarations(consts: { name: string; value: string }[], areExported: boolean = true): ts.VariableStatement {
    const modifiers = areExported ? [factory.createModifier(ts.SyntaxKind.ExportKeyword)] : undefined;

    return factory.createVariableStatement(
      modifiers,
      factory.createVariableDeclarationList(
        consts.map(({ name, value }) =>
          factory.createVariableDeclaration(
            name,
            undefined,
            undefined,
            factory.createAsExpression(factory.createStringLiteral(value), factory.createTypeReferenceNode("const"))
          )
        ),
        ts.NodeFlags.Const
      )
    );
  }

  private createTypeAliasDeclaration(name: string, type: ts.TypeNode): ts.TypeAliasDeclaration {
    return factory.createTypeAliasDeclaration([factory.createModifier(ts.SyntaxKind.ExportKeyword)], name, undefined, type);
  }

  private createRelationConstantAndTypeAlias(
    constantName: string,
    typeName: string,
    relations: string[]
  ): { constStatement: ts.VariableStatement; typeAlias: ts.TypeAliasDeclaration } {
    const constStatement = factory.createVariableStatement(
      [factory.createModifier(ts.SyntaxKind.ExportKeyword)],
      factory.createVariableDeclarationList(
        [
          factory.createVariableDeclaration(
            constantName,
            undefined,
            undefined,
            factory.createAsExpression(
              factory.createObjectLiteralExpression(
                relations.map((relation) =>
                  factory.createPropertyAssignment(
                    factory.createIdentifier(relation),
                    factory.createAsExpression(factory.createStringLiteral(relation), factory.createTypeReferenceNode("const"))
                  )
                ),
                true
              ),
              factory.createTypeReferenceNode("const")
            )
          ),
        ],
        ts.NodeFlags.Const
      )
    );

    // Generate relation type using string fallback for complex type
    const typeAlias = this.createTypeAliasDeclaration(
      typeName,
      factory.createIndexedAccessTypeNode(
        factory.createTypeQueryNode(factory.createIdentifier(constantName)),
        factory.createTypeOperatorNode(ts.SyntaxKind.KeyOfKeyword, factory.createTypeQueryNode(factory.createIdentifier(constantName)))
      )
    );

    return { constStatement, typeAlias };
  }
}
